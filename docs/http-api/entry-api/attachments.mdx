---
title: Entry Attachments
description: How to store and manage entry attachments using the system `$meta` entry.
---

<head>
  <link
    rel="canonical"
    href="https://www.reduct.store/docs/http-api/entry-api/attachments"
  />
</head>

# Attachments (`$meta`)

You can store **[attachments](../../glossary#attachment)** for any entry by writing records into a dedicated system entry:

```
<entry_name>/$meta
```

This is useful for schema fragments, calibration metadata, plugin configuration, or any small JSON payload that should travel with the entry.

Attachments use the same Entry API endpoints as regular records.
However, they have additional restrictions and requirements to ensure they are used, stored and replicated correctly and do not interfere with regular entry data.
Each attachment is identified by a required `key` label that allows storing multiple attachments in the same `$meta` entry and updating/removing them individually.

import SwaggerComponent from "@site/src/components/SwaggerComponent";

:::warning Reserved Keys
Attachment keys starting with `$` are reserved for internal ReductStore purposes.
Please use keys without a leading `$` for user-defined attachments.
:::

## Create or Replace an Attachment

Write the attachment content as a normal record body and set the attachment key label.

If a record with the same key already exists in the same `$meta` entry, ReductStore replaces it automatically.

For write requests:

- `x-reduct-label-key` is required.
- Writing with the same `key` replaces the previous attachment with that `key`.

Attachments can also be created with batch endpoints. The same rules apply: the entry path must end with `/$meta`, and the `key` label is required for each attachment record.

**Changes**:

- Version 1.19 (Unreleased): Entry attachments in system `$meta` entries were introduced.

<SwaggerComponent
  method="POST"
  path="/api/v1/b/:bucket_name/:entry_name/$meta"
  summary="Write an attachment record"
  parameters={[
    {
      type: "path",
      details: {
        name: ":bucket_name",
        description: "Name of bucket",
        isRequired: true,
      },
    },
    {
      type: "path",
      details: {
        name: ":entry_name",
        description: "Name of the parent entry (without `/$meta` suffix)",
        isRequired: true,
      },
    },
    {
      type: "query",
      details: {
        name: "ts",
        dataType: "Integer",
        description: "A UNIX timestamp in microseconds",
        isRequired: true,
      },
    },
    {
      type: "header",
      details: {
        name: "Content-Length",
        description: "Content size in bytes",
        isRequired: true,
      },
    },
    {
      type: "header",
      details: {
        name: "x-reduct-label-key",
        description:
          "Attachment key. Required for `$meta` records. Keys starting with `$` are reserved for internal use.",
        isRequired: true,
      },
    },
  ]}
  responses={[
    {
      status: "200",
      message: "OK",
      summary: "The attachment record is written",
    },
    {
      status: "401",
      message: "Unauthorized",
      summary: "Access token is invalid or empty",
    },
    {
      status: "403",
      message: "Forbidden",
      summary: "Access token does not have write permissions",
    },
    {
      status: "404",
      message: "Not Found",
      summary: "Bucket is not found",
    },
    {
      status: "409",
      message: "Conflict",
      summary:
        "A record with the same timestamp exists, or the bucket/entry is being deleted",
    },
    {
      status: "422",
      message: "Unprocessable Entity",
      summary:
        "Bad timestamp, missing label `key`, or `remove=true` used in write",
    },
  ]}
/>

If a `$meta` record with `key=$plugin` already exists, it is replaced by this new record.

## Read an Attachment

Reading attachments works exactly like reading regular records: use the attachment path and timestamp.

`$meta` is a system entry, so it is hidden from bucket `entry_count` and entry lists and can't be accessed with wildcard queries. You must read it by its exact path with `/$meta` suffix and timestamp.

<SwaggerComponent
  method="GET"
  path="/api/v1/b/:bucket_name/:entry_name/$meta"
  summary="Read an attachment record"
  parameters={[
    {
      type: "path",
      details: {
        name: ":bucket_name",
        description: "Name of bucket",
        isRequired: true,
      },
    },
    {
      type: "path",
      details: {
        name: ":entry_name",
        description: "Name of the parent entry (without `/$meta` suffix)",
        isRequired: true,
      },
    },
    {
      type: "query",
      details: {
        name: "ts",
        description:
          "A UNIX timestamp in microseconds. If empty, the latest record is returned.",
        isRequired: false,
      },
    },
  ]}
  responses={[
    {
      status: "200",
      message: "OK",
      summary: "The attachment record is returned in the response body",
    },
    {
      status: "204",
      message: "No Content",
      summary: "No record is available for the request",
    },
    {
      status: "401",
      message: "Unauthorized",
      summary: "Access token is invalid or empty",
    },
    {
      status: "403",
      message: "Forbidden",
      summary: "Access token does not have read permissions",
    },
    {
      status: "404",
      message: "Not Found",
      summary: "Bucket or entry doesn't exist",
    },
    {
      status: "409",
      message: "Conflict",
      summary: "The bucket is being deleted or the entry is being deleted",
    },
  ]}
/>

## Remove an Attachment

To remove an attachment, update labels of the existing `$meta` record and set `remove=true`.

This is intentionally done through `PATCH` (update), not through a write request.

The `PATCH` request must target an existing attachment record timestamp.

<SwaggerComponent
  method="PATCH"
  path="/api/v1/b/:bucket_name/:entry_name/$meta"
  summary="Remove attachment by key (`remove=true`)"
  parameters={[
    {
      type: "path",
      details: {
        name: ":bucket_name",
        description: "Name of bucket",
        isRequired: true,
      },
    },
    {
      type: "path",
      details: {
        name: ":entry_name",
        description: "Name of the parent entry (without `/$meta` suffix)",
        isRequired: true,
      },
    },
    {
      type: "query",
      details: {
        name: "ts",
        dataType: "Integer",
        description: "Timestamp of the existing `$meta` record to update",
        isRequired: true,
      },
    },
    {
      type: "header",
      details: {
        name: "x-reduct-label-key",
        description:
          "Attachment key. Keys starting with `$` are reserved for internal use.",
        isRequired: true,
      },
    },
    {
      type: "header",
      details: {
        name: "x-reduct-label-remove",
        description: "Set to `true` to remove the attachment record",
        isRequired: true,
      },
    },
  ]}
  responses={[
    {
      status: "200",
      message: "OK",
      summary: "The attachment record is removed",
    },
    {
      status: "401",
      message: "Unauthorized",
      summary: "Access token is invalid or empty",
    },
    {
      status: "403",
      message: "Forbidden",
      summary: "Access token does not have write permissions",
    },
    {
      status: "404",
      message: "Not Found",
      summary: "Bucket, entry, or record doesn't exist",
    },
    {
      status: "409",
      message: "Conflict",
      summary: "The bucket is being deleted or the entry is being deleted",
    },
    {
      status: "422",
      message: "Unprocessable Entity",
      summary: "Bad timestamp",
    },
  ]}
/>

## Delete `$meta` Entry Directly

Direct deletion of the system `$meta` entry is not allowed.

If you need to delete it, remove the parent entry instead. The `$meta` entry is removed together with its parent.

`$meta` records are included in bucket size/usage accounting, and `$meta` is renamed automatically when its parent entry is renamed.

<SwaggerComponent
  method="DELETE"
  path="/api/v1/b/:bucket_name/:entry_name/$meta"
  summary="Remove a `$meta` entry directly (forbidden)"
  parameters={[
    {
      type: "path",
      details: {
        name: ":bucket_name",
        description: "Name of bucket",
        isRequired: true,
      },
    },
    {
      type: "path",
      details: {
        name: ":entry_name",
        description: "Name of the parent entry (without `/$meta` suffix)",
        isRequired: true,
      },
    },
  ]}
  responses={[
    {
      status: "409",
      message: "Conflict",
      summary: "System `$meta` entry can be removed only with its parent entry",
    },
  ]}
/>

## Typical Flow

In practice, attachment handling usually looks like this:

1. Write attachment JSON to `<entry_name>/$meta` with a `key`.
2. Write a newer record with the same `key` when you need to update it.
3. Read the latest attachment record when needed.
4. Remove it with `PATCH` and `x-reduct-label-remove: true`.
