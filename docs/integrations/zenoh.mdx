---
title: Zenoh API
description: Ingest and query ReductStore data over Zenoh publish/subscribe and queryable interfaces.
sidebar_position: 4
---

<head>
  <link rel="canonical" href="https://www.reduct.store/docs/integrations/zenoh" />
</head>

# Zenoh API Integration

ReductStore includes an optional **Zenoh API** that lets you ingest and retrieve time-series records using the [Zenoh](https://zenoh.io) pub/sub and query protocol — alongside the existing HTTP API. This is especially useful in robotics and IoT edge deployments where Zenoh is already the messaging backbone and adding an HTTP stack is impractical.

:::info
The Zenoh API is compiled under the `zenoh-api` Cargo feature flag. Official Docker images ship with this feature enabled. If you build from source, add `--features zenoh-api` to your `cargo build` invocation.
:::

## How It Works

The integration runs as a sidecar runtime inside ReductStore and communicates directly with the storage engine — no HTTP round-trips are involved.

| Zenoh concept     | ReductStore mapping                                              |
| ----------------- | ---------------------------------------------------------------- |
| **Subscriber**    | Write path — samples published to a key expression are ingested  |
| **Queryable**     | Read path — queries against a key expression retrieve records    |
| **Key expression**| Becomes the **entry name** inside the configured bucket          |
| **Attachment**    | JSON-encoded map of **labels** (key-value metadata)              |
| **Timestamp**     | Zenoh NTP-64 timestamp → stored as Unix microseconds             |

All data lands in a single, configurable ReductStore bucket (single-bucket mode). The bucket is created automatically if it does not exist.

## Configuration

The Zenoh API is controlled entirely through environment variables (or Docker `-e` flags). All variables are optional unless noted.

### Enabling the Integration

| Variable              | Default  | Description                                                   |
| --------------------- | -------- | ------------------------------------------------------------- |
| `RS_ZENOH_ENABLED`    | `false`  | Set to `true`, `1`, `yes`, or `on` to enable the Zenoh API   |

The Zenoh API is disabled by default. No Zenoh sockets are opened unless this variable is set to a truthy value.

### Session Configuration

Exactly **one** of the two config variables below is required when `RS_ZENOH_ENABLED=true`:

| Variable                | Default | Description                                                                                   |
| ----------------------- | ------- | --------------------------------------------------------------------------------------------- |
| `RS_ZENOH_CONFIG`       | —       | Inline config string, e.g. `mode=client;peer=tcp/localhost:7447`. Takes precedence over path. |
| `RS_ZENOH_CONFIG_PATH`  | —       | Path to a Zenoh JSON5 config file (e.g. `/etc/reductstore/zenoh.json5`)                       |

#### Inline config format

The inline config is a semicolon-separated list of `key=value` pairs:

| Key              | Example value             | Description                                              |
| ---------------- | ------------------------- | -------------------------------------------------------- |
| `mode`           | `client`, `peer`, `router`| Zenoh session mode                                       |
| `peer` / `connect` | `tcp/localhost:7447`    | Comma-separated connect endpoints                        |
| `listen`         | `tcp/0.0.0.0:7447`        | Comma-separated listen endpoints                         |

Example:

```
RS_ZENOH_CONFIG=mode=client;peer=tcp/192.168.1.10:7447
```

Unknown keys are logged as warnings and ignored. For advanced session settings (TLS, multicast discovery, scouting, etc.) use a JSON5 config file instead.

#### JSON5 config file

Pass the path to a standard [Zenoh JSON5 configuration file](https://github.com/eclipse-zenoh/zenoh/blob/main/DEFAULT_CONFIG.json5):

```
RS_ZENOH_CONFIG_PATH=/etc/reductstore/zenoh.json5
```

### Storage Mapping

| Variable                | Default  | Description                                                                          |
| ----------------------- | -------- | ------------------------------------------------------------------------------------ |
| `RS_ZENOH_BUCKET`       | `zenoh`  | Target ReductStore bucket. Created automatically if it does not exist.               |

### Key Expression Routing

| Variable                  | Default | Description                                                                                                         |
| ------------------------- | ------- | ------------------------------------------------------------------------------------------------------------------- |
| `RS_ZENOH_SUB_KEYEXPRS`   | —       | Key expression for the Zenoh **subscriber** (write path). If unset, the write path is disabled.                     |
| `RS_ZENOH_QUERY_KEYEXPRS` | —       | Key expression for the Zenoh **queryable** (read path). If unset, the read path is disabled.                        |

Use standard Zenoh wildcards: `*` for a single segment, `**` for any number of segments.

Examples:

| `RS_ZENOH_SUB_KEYEXPRS` | What is matched                                     |
| ----------------------- | --------------------------------------------------- |
| `**`                    | All key expressions                                 |
| `robot1/**`             | All keys under the `robot1` prefix                  |
| `factory/line1/*`       | All single-segment keys under `factory/line1`       |

## Write Path (Subscriber)

When a Zenoh publisher sends a sample to a key expression that matches `RS_ZENOH_SUB_KEYEXPRS`:

1. The full key expression becomes the **entry name** (leading/trailing `/` are stripped).
2. The sample payload (bytes) is written to that entry in `RS_ZENOH_BUCKET`.
3. If the sample carries a **Zenoh timestamp**, it is converted from NTP-64 to Unix microseconds and used as the record timestamp. Otherwise, the server's wall clock is used.
4. If the sample carries a **Zenoh attachment**, it is decoded as a JSON object and stored as record **labels**.

### Sending Labels

Attach a JSON-serialised label map to the Zenoh sample to annotate each record:

```python
import zenoh, json

session = zenoh.open(zenoh.Config())
# Publish with labels as attachment
session.put(
    "factory/line1/camera",
    b"<binary payload>",
    attachment=json.dumps({"robot": "alpha", "status": "ok"}).encode(),
)
```

## Read Path (Queryable)

When a Zenoh client sends a query to a key expression that matches `RS_ZENOH_QUERY_KEYEXPRS`, ReductStore resolves it against the storage and replies with the matching records.

The key expression maps to the **entry name** within `RS_ZENOH_BUCKET`. Query parameters are passed as Zenoh selector parameters (`?key=value&...`).

### Point-in-time Lookup

Fetch the single record at an exact timestamp (Unix microseconds):

| Parameter | Type   | Description                                        |
| --------- | ------ | -------------------------------------------------- |
| `ts`      | uint64 | Exact record timestamp in Unix microseconds        |

```python
replies = session.get("factory/line1/camera?ts=1700000000000000")
for reply in replies:
    print(reply.ok.payload)
```

### Time-range Query

If `ts` is not set, a streaming range query is performed. The following parameters are supported:

| Parameter       | Type    | Description                                                                                           |
| --------------- | ------- | ----------------------------------------------------------------------------------------------------- |
| `start`         | uint64  | Range start timestamp (Unix µs, inclusive). Defaults to the oldest record.                            |
| `stop`          | uint64  | Range stop timestamp (Unix µs, exclusive). Defaults to the latest record.                             |
| `each_s`        | float   | Return at most one record every N seconds (must be > 0).                                              |
| `each_n`        | uint64  | Return every Nth record (must be > 0).                                                                |
| `limit`         | uint64  | Maximum number of records to return.                                                                  |
| `continuous`    | bool    | Keep the query alive and stream new records as they arrive.                                           |
| `ttl`           | uint64  | Time-to-live for a continuous query in seconds.                                                       |
| `metadata`      | bool    | If `true`, skip payload — return labels and timestamps only.                                          |
| `include-<key>` | string  | Only return records where label `<key>` equals the value, e.g. `include-robot=alpha`.                 |
| `exclude-<key>` | string  | Exclude records where label `<key>` equals the value, e.g. `exclude-status=error`.                   |

```python
# Fetch up to 100 records between two timestamps
replies = session.get(
    "factory/line1/camera",
    parameters="start=1700000000000000&stop=1700086400000000&limit=100"
)
for reply in replies:
    print(reply.ok.payload.to_bytes())
```

### Reading Labels from Replies

Labels are returned as a JSON attachment on each reply sample:

```python
import json

for reply in replies:
    sample = reply.ok
    labels = {}
    if sample.attachment is not None:
        labels = json.loads(sample.attachment.to_bytes())
    print(labels)
```

## Quick Start with Docker

The following example starts ReductStore with the Zenoh API enabled in client mode, connecting to a Zenoh router at `192.168.1.10:7447`. All published data is stored in the `sensors` bucket; the subscriber listens on all key expressions and the queryable answers queries on all key expressions.

```bash
docker run -d \
  -p 8383:8383 \
  -v ${PWD}/data:/data \
  -e RS_ZENOH_ENABLED=true \
  -e RS_ZENOH_CONFIG="mode=client;peer=tcp/192.168.1.10:7447" \
  -e RS_ZENOH_BUCKET=sensors \
  -e RS_ZENOH_SUB_KEYEXPRS="**" \
  -e RS_ZENOH_QUERY_KEYEXPRS="**" \
  reduct/store:latest
```

### Using a JSON5 Config File

Mount a config file into the container when you need advanced Zenoh settings:

```bash
docker run -d \
  -p 8383:8383 \
  -v ${PWD}/data:/data \
  -v ${PWD}/zenoh.json5:/etc/reductstore/zenoh.json5:ro \
  -e RS_ZENOH_ENABLED=true \
  -e RS_ZENOH_CONFIG_PATH=/etc/reductstore/zenoh.json5 \
  -e RS_ZENOH_BUCKET=sensors \
  -e RS_ZENOH_SUB_KEYEXPRS="**" \
  reduct/store:latest
```

## Configuration Reference Summary

| Variable                  | Default  | Description                                                   |
| ------------------------- | -------- | ------------------------------------------------------------- |
| `RS_ZENOH_ENABLED`        | `false`  | Enable the Zenoh API (`true`/`1`/`yes`/`on`)                 |
| `RS_ZENOH_CONFIG`         | —        | Inline Zenoh config string (takes precedence over path)       |
| `RS_ZENOH_CONFIG_PATH`    | —        | Path to a Zenoh JSON5 config file                             |
| `RS_ZENOH_BUCKET`         | `zenoh`  | Target bucket (auto-created if missing)                       |
| `RS_ZENOH_SUB_KEYEXPRS`   | —        | Key expression for subscriber (write path). Disabled if unset |
| `RS_ZENOH_QUERY_KEYEXPRS` | —        | Key expression for queryable (read path). Disabled if unset   |

## Relationship to the HTTP API

The Zenoh API is additive — the HTTP API continues to operate normally alongside it. Data written via Zenoh appears immediately in the HTTP API and vice versa. This means you can:

- Ingest sensor data over Zenoh from constrained edge devices.
- Query and visualise historical records via the HTTP API or the [**Web Console**](/docs/getting-started).
- Replicate data to the cloud using [**Data Replication**](/docs/guides/data-replication).

## Limitations

- **Single-bucket mode only.** All Zenoh data maps to one configured bucket. Multi-bucket routing based on key expression is not yet supported.
- **No authentication.** The Zenoh layer itself does not enforce ReductStore access-control tokens. Secure the Zenoh network at the transport level (e.g. TLS, private VLAN).
- **Binary payload only.** The Zenoh API always stores and returns raw bytes with content type `application/octet-stream`. Use labels to carry semantic metadata.
- **Write-once semantics.** ReductStore records are immutable. A Zenoh sample with a timestamp that already exists in the entry will be rejected.
