---
title: Zenoh API
description: Ingest and query ReductStore data over Zenoh publish/subscribe and queryable interfaces.
sidebar_position: 4
---

<head>
  <link rel="canonical" href="https://www.reduct.store/docs/integrations/zenoh" />
</head>

# Zenoh API

ReductStore can receive and serve time-series data directly over [**Zenoh**](https://zenoh.io), using its native pub/sub and query primitives. This is an alternative ingestion and retrieval path that runs alongside the existing HTTP API — both work at the same time and share the same stored data.

This page explains how to enable the Zenoh API, how to configure it, and what you can and cannot do with it compared to the HTTP API.

:::info
The Zenoh API is compiled under the `zenoh-api` Cargo feature flag. Official Docker images ship with this feature enabled. If you build from source, add `--features zenoh-api` to your `cargo build` invocation.
:::

## How It Works

ReductStore opens a Zenoh session on startup and registers a **subscriber** (for writes) and a **queryable** (for reads). Both talk directly to the storage engine without going through HTTP.

| Zenoh concept      | ReductStore mapping                                                                                                                              |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Subscriber**     | Write path. Samples published to keys matching the configured key expression are ingested.                                                        |
| **Queryable**      | Read path. Queries whose selector matches the configured key expression retrieve **[records](../glossary#record)**.                               |
| **Key**            | The concrete address of a sample (e.g. `robot/arm/joint1`). Becomes the **[entry](../glossary#entry)** name in the **[bucket](../glossary#bucket)**. |
| **Key expression** | A wildcard pattern (e.g. `robot/**`). Used to configure which keys the subscriber and queryable respond to.                                      |
| **Encoding**       | Mapped to the **[record](../glossary#record)**'s **content type**.                                                                               |
| **Attachment**     | JSON-encoded map of **[labels](../glossary#label)** (key-value metadata).                                                                        |
| **Timestamp**      | Zenoh HLC timestamp converted to Unix microseconds.                                                                                              |

All data is stored in a single ReductStore bucket. The bucket is created automatically if it does not exist.

## Key Expressions

In Zenoh, a **key** is a concrete address for a value, such as `organizationA/building8/room275/sensor3/temperature`. A **key expression** is a pattern defined using the [**Key Expression Language**](https://github.com/eclipse-zenoh/roadmap/blob/main/rfcs/ALL/Key%20Expressions.md) that can match a set of keys.

`RS_ZENOH_SUB_KEYEXPRS` and `RS_ZENOH_QUERY_KEYEXPRS` take key expressions — they define which keys the subscriber and queryable respond to. The **key** of each individual sample (the concrete address it was published to) is what becomes the entry name in ReductStore.

A key is a `/`-separated sequence of non-empty UTF-8 segments, similar to a filesystem path. Individual key segments may not contain `*`, `$`, `?`, or `#`.

Key expressions extend plain keys with three wildcards. The following table and examples are taken from the [**Zenoh abstractions documentation**](https://zenoh.io/docs/manual/abstractions/):

| Wildcard | Matches                                                                                 | Example                                         |
| -------- | --------------------------------------------------------------------------------------- | ----------------------------------------------- |
| `*`      | Any single segment (not including `/`). Must be surrounded by `/` or be the whole chunk | `robot1/*/temperature` matches `robot1/imu/temperature` but not `robot1/a/b/temperature` |
| `$*`     | Any substring within a single segment, including an empty string                        | `robot$*/temperature` matches `robot1/temperature` and `robotA/temperature`              |
| `**`     | Any number of segments, including none. Must appear after `/` or at the start           | `factory/**/temperature` matches all temperature keys under `factory` at any depth       |

:::tip
Prefer `*` and `**` over `$*` when designing your key space. `$*` is slower and is usually only needed when different identifiers are mixed within the same segment — e.g. `robot12` and `pc18`. Structuring keys as `robot/12` and `pc/18` instead avoids this.
:::

See the [**Zenoh abstractions documentation**](https://zenoh.io/docs/manual/abstractions/) for the full key expression specification.

## Selectors

When querying, Zenoh uses a **selector** — a key expression optionally followed by `?` and a list of parameters. The following syntax is from the [**Zenoh abstractions documentation**](https://zenoh.io/docs/manual/abstractions/):

```
factory/**/temperature?start=1700000000000000&limit=100
^                     ^ ^
|--- key expression --| |------ parameters ------|
```

The key expression part is used by Zenoh routers to route the query to the right queryable. The parameters are passed through to ReductStore and interpreted as query filters (see [**Time-range Query**](#time-range-query) below). Parameters are `&`-separated `key=value` pairs, and values may be URL-encoded.

## Configuration

The Zenoh API is configured entirely through environment variables. All variables are optional unless noted.

### Enabling the API

| Name               | Default | Description                                                 |
| ------------------ | ------- | ----------------------------------------------------------- |
| `RS_ZENOH_ENABLED` | `false` | Set to `true`, `1`, `yes`, or `on` to enable the Zenoh API |

No Zenoh sockets are opened until this is set to a truthy value.

### Session Configuration

Exactly **one** of the two variables below is required when `RS_ZENOH_ENABLED=true`:

| Name                   | Default | Description                                                                                  |
| ---------------------- | ------- | -------------------------------------------------------------------------------------------- |
| `RS_ZENOH_CONFIG`      | —       | Inline config string, e.g. `mode=client;peer=tcp/localhost:7447`. Takes precedence over path |
| `RS_ZENOH_CONFIG_PATH` | —       | Path to a Zenoh JSON5 config file (e.g. `/etc/reductstore/zenoh.json5`)                      |

#### Inline config format

The inline config is a semicolon-separated list of `key=value` pairs:

| Key                | Example value              | Description                         |
| ------------------ | -------------------------- | ----------------------------------- |
| `mode`             | `client`, `peer`, `router` | Zenoh session mode                  |
| `peer` / `connect` | `tcp/localhost:7447`       | Comma-separated connect endpoints   |
| `listen`           | `tcp/0.0.0.0:7447`         | Comma-separated listen endpoints    |

```
RS_ZENOH_CONFIG=mode=client;peer=tcp/192.168.1.10:7447
```

Unknown keys are logged as warnings and ignored. For advanced session settings (TLS, multicast discovery, scouting, and so on), use a JSON5 config file instead.

#### JSON5 config file

Pass the path to a standard [**Zenoh JSON5 configuration file**](https://github.com/eclipse-zenoh/zenoh/blob/main/DEFAULT_CONFIG.json5):

```
RS_ZENOH_CONFIG_PATH=/etc/reductstore/zenoh.json5
```

### Storage Mapping

| Name              | Default | Description                                                            |
| ----------------- | ------- | ---------------------------------------------------------------------- |
| `RS_ZENOH_BUCKET` | `zenoh` | Target ReductStore bucket. Created automatically if it does not exist. |

### Key Expression Routing

| Name                      | Default | Description                                                                      |
| ------------------------- | ------- | -------------------------------------------------------------------------------- |
| `RS_ZENOH_SUB_KEYEXPRS`   | —       | Key expression for the subscriber (write path). Disabled if unset.               |
| `RS_ZENOH_QUERY_KEYEXPRS` | —       | Key expression for the queryable (read path). Disabled if unset.                 |

Both values follow the [**Key Expression Language**](#key-expressions) described above.

## Write Path

When a Zenoh publisher sends a sample to a key expression that matches `RS_ZENOH_SUB_KEYEXPRS`:

1. The sample's key becomes the entry name (leading and trailing `/` are stripped).
2. The sample payload is written to that entry in `RS_ZENOH_BUCKET`.
3. The sample's **encoding** is mapped to the record's **content type**. If no encoding is set, the content type defaults to `application/octet-stream`.
4. If the sample carries a Zenoh timestamp, it is converted from HLC to Unix microseconds and used as the record timestamp. Otherwise the server clock is used.
5. If the sample carries a Zenoh attachment, it is decoded as a JSON object and stored as record labels.

### Encoding and Content Type

Zenoh samples carry an optional encoding that describes the format of their payload. ReductStore stores this as the record's content type, making it available when reading back the data over HTTP or Zenoh.

Standard Zenoh encodings like `text/plain`, `application/json`, or `image/jpeg` map directly to their MIME type equivalents in ReductStore. If you publish without setting an encoding, the content type defaults to `application/octet-stream`.

```python
import zenoh

session = zenoh.open(zenoh.Config())

# Publish JSON with explicit encoding
session.put(
    "factory/line1/status",
    b'{"state": "running", "speed": 120}',
    encoding=zenoh.Encoding.APPLICATION_JSON,
)

# Publish binary data (defaults to application/octet-stream)
session.put("factory/line1/camera", b"<raw image bytes>")
```

### Sending Labels

Attach a JSON label map to the Zenoh sample to annotate the record:

```python
import zenoh, json

session = zenoh.open(zenoh.Config())
session.put(
    "factory/line1/camera",
    b"<binary payload>",
    attachment=json.dumps({"robot": "alpha", "status": "ok"}).encode(),
)
```

## Read Path

When a Zenoh client sends a query to a key expression that matches `RS_ZENOH_QUERY_KEYEXPRS`, ReductStore looks up the matching records and replies with them.

The query takes the form of a [**selector**](#selectors): the key part of the selector maps to the entry name within `RS_ZENOH_BUCKET`, and the parameters after `?` control which records are returned.

### Point-in-time Lookup

Fetch the single record at an exact timestamp:

| Parameter | Description                                 | Type      |
| --------- | ------------------------------------------- | --------- |
| `ts`      | Exact record timestamp in Unix microseconds | Timestamp |

```python
replies = session.get("factory/line1/camera?ts=1700000000000000")
for reply in replies:
    print(reply.ok.payload.to_bytes())
```

### Time-range Query

If `ts` is not set, a range query is performed. The following parameters are supported:

| Parameter       | Description                                                                    | Type      | Default                            |
| --------------- | ------------------------------------------------------------------------------ | --------- | ---------------------------------- |
| `start`         | Range start timestamp (Unix µs, inclusive)                                     | Timestamp | Timestamp of the first record      |
| `stop`          | Range stop timestamp (Unix µs, exclusive)                                      | Timestamp | Timestamp of the last record       |
| `each_s`        | Return at most one record every N seconds (must be greater than 0)             | Float     |                                    |
| `each_n`        | Return every Nth record (must be greater than 0)                               | Integer   |                                    |
| `limit`         | Maximum number of records to return                                            | Integer   |                                    |
| `continuous`    | Keep the query alive and stream new records as they arrive                     | Boolean   | False                              |
| `ttl`           | Time-to-live for a continuous query in seconds                                 | Integer   | 60                                 |
| `metadata`      | Return labels and timestamps only, without payload                             | Boolean   | False                              |
| `include-<key>` | Only return records where label `<key>` equals the value, e.g. `include-robot=alpha` | String |                             |
| `exclude-<key>` | Exclude records where label `<key>` equals the value, e.g. `exclude-status=error`   | String |                             |

```python
replies = session.get(
    "factory/line1/camera",
    parameters="start=1700000000000000&stop=1700086400000000&limit=100"
)
for reply in replies:
    print(reply.ok.payload.to_bytes())
```

### Reading Labels from Replies

Labels are returned as a JSON attachment on each reply sample:

```python
import json

for reply in replies:
    sample = reply.ok
    labels = {}
    if sample.attachment is not None:
        labels = json.loads(sample.attachment.to_bytes())
    print(labels)
```

## Quick Start with Docker

Start ReductStore with the Zenoh API in client mode, connecting to a Zenoh router at `192.168.1.10:7447`. All published data lands in the `sensors` bucket.

```bash
docker run -d \
  -p 8383:8383 \
  -v ${PWD}/data:/data \
  -e RS_ZENOH_ENABLED=true \
  -e RS_ZENOH_CONFIG="mode=client;peer=tcp/192.168.1.10:7447" \
  -e RS_ZENOH_BUCKET=sensors \
  -e RS_ZENOH_SUB_KEYEXPRS="**" \
  -e RS_ZENOH_QUERY_KEYEXPRS="**" \
  reduct/store:latest
```

### Using a JSON5 Config File

Mount a config file into the container when you need advanced Zenoh settings:

```bash
docker run -d \
  -p 8383:8383 \
  -v ${PWD}/data:/data \
  -v ${PWD}/zenoh.json5:/etc/reductstore/zenoh.json5:ro \
  -e RS_ZENOH_ENABLED=true \
  -e RS_ZENOH_CONFIG_PATH=/etc/reductstore/zenoh.json5 \
  -e RS_ZENOH_BUCKET=sensors \
  -e RS_ZENOH_SUB_KEYEXPRS="**" \
  reduct/store:latest
```

## Configuration Reference

| Name                      | Default | Description                                                       |
| ------------------------- | ------- | ----------------------------------------------------------------- |
| `RS_ZENOH_ENABLED`        | `false` | Enable the Zenoh API (`true`, `1`, `yes`, `on`)                   |
| `RS_ZENOH_CONFIG`         | —       | Inline Zenoh config string (takes precedence over path)           |
| `RS_ZENOH_CONFIG_PATH`    | —       | Path to a Zenoh JSON5 config file                                 |
| `RS_ZENOH_BUCKET`         | `zenoh` | Target bucket (auto-created if missing)                           |
| `RS_ZENOH_SUB_KEYEXPRS`   | —       | Key expression for the subscriber (write path). Disabled if unset |
| `RS_ZENOH_QUERY_KEYEXPRS` | —       | Key expression for the queryable (read path). Disabled if unset   |

## Using the HTTP API alongside Zenoh

The HTTP API stays fully operational when the Zenoh API is enabled. Data written via Zenoh is immediately visible over HTTP and vice versa. A typical setup uses Zenoh for ingestion from edge nodes and the HTTP API or Web Console for querying, management, and replication.

Data management operations such as deleting records, entries, or buckets are not available through the Zenoh API. Use the [**HTTP API**](/docs/http-api) for those.

## Authentication

Zenoh has its own access control system, separate from ReductStore API tokens. ReductStore registers itself as a regular Zenoh node. Any Zenoh node that is allowed to connect to the session can publish and query data.

You configure who can connect, and what they can do, at the Zenoh level using:

- [**Access control rules**](https://zenoh.io/docs/manual/access-control/) to allow or deny operations on specific key expressions per subject
- [**User-password authentication**](https://zenoh.io/docs/manual/user-password/) to authenticate clients and peers before they join the session
- [**TLS authentication**](https://zenoh.io/docs/manual/tls/) for mutual certificate-based authentication

ReductStore API tokens are not checked for Zenoh connections. If you need per-token access control on top of Zenoh, use the HTTP API.

## Current Limitations

- **Single-bucket mode.** All Zenoh data maps to one configured bucket. Routing to different buckets based on the key expression is not yet supported.
- **No data deletion.** Records, entries, and buckets cannot be deleted through the Zenoh API. Use the [**HTTP API**](/docs/http-api) for data management operations.
- **Limited query parameters.** The Zenoh API exposes a fixed set of query parameters (`start`, `stop`, `limit`, and so on). The full [**ReductStore query language**](/docs/guides/data-querying) — including conditional `when` expressions and strict mode — is not available over Zenoh.
- **No topic-to-label mapping.** There is no way to map a Zenoh key or key expression to a ReductStore label. For example, it is not currently possible to store data from multiple Zenoh topics as records under a single entry and use the topic name as a label.
