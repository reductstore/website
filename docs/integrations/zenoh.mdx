---
title: Zenoh API
description: Ingest and query ReductStore data over Zenoh publish/subscribe and queryable interfaces.
sidebar_position: 4
---

<head>
  <link
    rel="canonical"
    href="https://www.reduct.store/docs/integrations/zenoh"
  />
</head>

# Zenoh API

ReductStore can receive and serve time-series data directly over [**Zenoh**](https://zenoh.io), using its native pub/sub and query primitives. This is an alternative ingestion and retrieval path that runs alongside the existing HTTP API. Both work at the same time and share the same stored data.

:::info
The Zenoh API is compiled under the `zenoh-api` Cargo feature flag. Official Docker images ship with this feature enabled. If you build from source, add `--features zenoh-api` to your `cargo build` invocation.
:::

## How It Works

ReductStore opens a Zenoh session on startup and registers a **subscriber** (for writes) and a **queryable** (for reads). Both talk directly to the storage engine without going through HTTP.

| Zenoh concept      | ReductStore mapping                                                                                                                                  |
| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Subscriber**     | Write path. Samples published to keys matching the configured key expression are ingested.                                                           |
| **Queryable**      | Read path. Queries whose selector matches the configured key expression retrieve **[records](../glossary#record)**.                                  |
| **Key**            | The concrete address of a sample (e.g. `robot/arm/joint1`). Becomes the **[entry](../glossary#entry)** name in the **[bucket](../glossary#bucket)**. |
| **Key expression** | A wildcard pattern (e.g. `robot/**`). Used to configure which keys the subscriber and queryable respond to.                                          |
| **Encoding**       | Mapped to the record's **content type**.                                                                                                             |
| **Attachment**     | JSON-encoded map of **[labels](../glossary#label)** (key-value metadata).                                                                            |
| **Timestamp**      | Zenoh HLC timestamp converted to Unix microseconds.                                                                                                  |

:::info
All data is stored in a single ReductStore bucket. The bucket is created automatically if it does not exist.
:::

## Key Expressions

In Zenoh, a **key** is a concrete address for a value, such as `organizationA/building8/room275/sensor3/temperature`. A **key expression** is a pattern defined using the [**Key Expression Language**](https://github.com/eclipse-zenoh/roadmap/blob/main/rfcs/ALL/Key%20Expressions.md) that can match a set of keys.

`RS_ZENOH_SUB_KEYEXPRS` and `RS_ZENOH_QUERY_KEYEXPRS` take key expressions. They define which keys the subscriber and queryable respond to. The **key** of each individual sample (the concrete address it was published to) is what becomes the entry name in ReductStore.

A key is a `/`-separated sequence of non-empty UTF-8 segments, similar to a filesystem path. Individual key segments may not contain `*`, `$`, `?`, or `#`.

Key expressions extend plain keys with three wildcards. The following table and examples are taken from the [**Zenoh abstractions documentation**](https://zenoh.io/docs/manual/abstractions/):

| Wildcard | Matches                                                                                 | Example                                                                                  |
| -------- | --------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| `*`      | Any single segment (not including `/`). Must be surrounded by `/` or be the whole chunk | `robot1/*/temperature` matches `robot1/imu/temperature` but not `robot1/a/b/temperature` |
| `$*`     | Any substring within a single segment, including an empty string                        | `robot$*/temperature` matches `robot1/temperature` and `robotA/temperature`              |
| `**`     | Any number of segments, including none. Must appear after `/` or at the start           | `factory/**/temperature` matches all temperature keys under `factory` at any depth       |

:::tip
Prefer `*` and `**` over `$*` when designing your key space. According to Zenoh's documentation, `$*` is slower and is usually only needed when different identifiers are mixed within the same segment, e.g. `robot12` and `pc18`. Structuring keys as `robot/12` and `pc/18` instead avoids this.
:::

See the [**Zenoh abstractions documentation**](https://zenoh.io/docs/manual/abstractions/) for the full key expression specification.

## Selectors

When querying, Zenoh uses a **selector** which is a key expression optionally followed by `?` and a list of parameters. The following syntax is from the [**Zenoh abstractions documentation**](https://zenoh.io/docs/manual/abstractions/):

```
factory/**/temperature?start=1700000000000000&limit=100
^                     ^ ^
|--- key expression --| |------ parameters ------|
```

The key expression part is used by Zenoh routers to route the query to the right queryable. The parameters are passed through to ReductStore and interpreted as query filters (see [**Time-range Query**](#time-range-query) below). Parameters are `&`-separated `key=value` pairs, and values may be URL-encoded.

## Configuration

Keep configuration in one place: use the **[Zenoh API Settings](../configuration/settings#zenoh-api-settings)** section in the configuration guide.

The only detail worth repeating here is the inline format for `RS_ZENOH_CONFIG`:

| Key                | Example value              | Description                       |
| ------------------ | -------------------------- | --------------------------------- |
| `mode`             | `client`, `peer`, `router` | Zenoh session mode                |
| `peer` / `connect` | `tcp/localhost:7447`       | Comma-separated connect endpoints |
| `listen`           | `tcp/0.0.0.0:7447`         | Comma-separated listen endpoints  |

```
RS_ZENOH_CONFIG=mode=client;peer=tcp/192.168.1.10:7447
```

For advanced session settings, use `RS_ZENOH_CONFIG_PATH` with a [**Zenoh JSON5 configuration file**](https://github.com/eclipse-zenoh/zenoh/blob/main/DEFAULT_CONFIG.json5).

## Write Path

When a Zenoh publisher sends a sample to a key expression that matches `RS_ZENOH_SUB_KEYEXPRS`:

1. The sample's key becomes the entry name (leading and trailing `/` are stripped).
2. The sample payload is written to that entry in `RS_ZENOH_BUCKET`.
3. The sample's **encoding** is mapped to the record's **content type**. If no encoding is set, the content type defaults to `application/octet-stream`.
4. If the sample carries a Zenoh timestamp, it is converted from HLC to Unix microseconds and used as the record timestamp. Otherwise the server clock is used.
5. If the sample carries a Zenoh attachment, it is decoded as a JSON object and stored as record labels.

### Encoding and Content Type

Zenoh samples carry an optional encoding that describes the format of their payload. ReductStore stores this as the record's content type, making it available when reading back the data over HTTP or Zenoh.

Standard Zenoh encodings like `text/plain`, `application/json`, or `image/jpeg` map directly to their MIME type equivalents in ReductStore. If you publish without setting an encoding, the content type defaults to `application/octet-stream`.

```python
import zenoh

with zenoh.open(zenoh.Config()) as session:
    # Publish JSON with explicit encoding
    session.put(
        "factory/line1/status",
        b'{"state": "running", "speed": 120}',
        encoding=zenoh.Encoding.APPLICATION_JSON,
    )

    # Publish binary data (defaults to application/octet-stream)
    session.put("factory/line1/camera", b"<raw image bytes>")
```

### Sending Labels

Attach a JSON label map to the Zenoh sample to annotate the record:

```python
import zenoh, json

with zenoh.open(zenoh.Config()) as session:
    session.put(
        "factory/line1/camera",
        b"<binary payload>",
        attachment=json.dumps({"robot": "alpha", "status": "ok"}).encode(),
    )
```

## Read Path

When a Zenoh client sends a query to a key expression that matches `RS_ZENOH_QUERY_KEYEXPRS`, ReductStore looks up the matching records and replies with them.

The query takes the form of a [**selector**](#selectors): the key part of the selector maps to the entry name within `RS_ZENOH_BUCKET`, and the parameters after `?` control which records are returned.

### Point-in-time Lookup

Fetch the single record at an exact timestamp:

| Parameter | Description                                 | Type      |
| --------- | ------------------------------------------- | --------- |
| `ts`      | Exact record timestamp in Unix microseconds | Timestamp |

```python
import zenoh

with zenoh.open(zenoh.Config()) as session:
    replies = session.get("factory/line1/camera?ts=1700000000000000")
    for reply in replies:
        print(reply.ok.payload.to_bytes())
```

### Time-range Query

If `ts` is not set, a range query is performed. The following parameters are supported:

| Parameter       | Description                                                                          | Type      | Default                       |
| --------------- | ------------------------------------------------------------------------------------ | --------- | ----------------------------- |
| `start`         | Range start timestamp (Unix µs, inclusive)                                           | Timestamp | Timestamp of the first record |
| `stop`          | Range stop timestamp (Unix µs, exclusive)                                            | Timestamp | Timestamp of the last record  |
| `each_s`        | Return at most one record every N seconds (must be greater than 0)                   | Float     |                               |
| `each_n`        | Return every Nth record (must be greater than 0)                                     | Integer   |                               |
| `limit`         | Maximum number of records to return                                                  | Integer   |                               |
| `metadata`      | Return labels and timestamps only, without payload                                   | Boolean   | False                         |
| `include-<key>` | Only return records where label `<key>` equals the value, e.g. `include-robot=alpha` | String    |                               |
| `exclude-<key>` | Exclude records where label `<key>` equals the value, e.g. `exclude-status=error`    | String    |                               |

```python
import zenoh

with zenoh.open(zenoh.Config()) as session:
    replies = session.get(
        "factory/line1/camera",
        parameters="start=1700000000000000&stop=1700086400000000&limit=100"
    )
    for reply in replies:
        print(reply.ok.payload.to_bytes())
```

### Reading Labels from Replies

Labels are returned as a JSON attachment on each reply sample:

```python
import zenoh
import json

with zenoh.open(zenoh.Config()) as session:
    replies = session.get("factory/line1/camera?limit=1")
    for reply in replies:
        sample = reply.ok
        labels = {}
        if sample.attachment is not None:
            labels = json.loads(sample.attachment.to_bytes())
        print(labels)
```

## Current Limitations

- **Single-bucket mode.** All Zenoh data maps to one configured bucket. Routing to different buckets based on the key expression is not yet supported.
- **No data deletion.** Records, entries, and buckets cannot be deleted through the Zenoh API. Use the [**HTTP API**](/docs/http-api) for data management operations.
- **Limited query parameters.** The Zenoh API exposes a fixed set of query parameters (`start`, `stop`, `limit`, and so on). The full [**ReductStore query language**](/docs/guides/data-querying) — including conditional `when` expressions and strict mode — is not available over Zenoh.
- **No topic-to-label mapping.** There is no way to map a Zenoh key or key expression to a ReductStore label. For example, it is not currently possible to store data from multiple Zenoh topics as records under a single entry and use the topic name as a label.
