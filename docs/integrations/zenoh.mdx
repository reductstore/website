---
title: Zenoh API
description: Ingest and query ReductStore data over Zenoh publish/subscribe and queryable interfaces.
sidebar_position: 4
---

<head>
  <link rel="canonical" href="https://www.reduct.store/docs/integrations/zenoh" />
</head>

# Zenoh API

ReductStore can receive and serve time-series data directly over [Zenoh](https://zenoh.io), using its native pub/sub and query primitives. This is an alternative ingestion and retrieval path that runs alongside the existing HTTP API — both work at the same time and share the same stored data.

This page explains how to enable the Zenoh API, how to configure it, and what you can and cannot do with it compared to the HTTP API.

:::info
The Zenoh API is compiled under the `zenoh-api` Cargo feature flag. Official Docker images ship with this feature enabled. If you build from source, add `--features zenoh-api` to your `cargo build` invocation.
:::

## How It Works

ReductStore opens a Zenoh session on startup and registers a **subscriber** (for writes) and a **queryable** (for reads). Both talk directly to the storage engine without going through HTTP.

| Zenoh concept      | ReductStore mapping                                             |
| ------------------ | --------------------------------------------------------------- |
| **Subscriber**     | Write path. Samples published to a key expression are ingested. |
| **Queryable**      | Read path. Queries against a key expression retrieve records.   |
| **Key expression** | Becomes the **entry name** inside the configured bucket.        |
| **Attachment**     | JSON-encoded map of **labels** (key-value metadata).            |
| **Timestamp**      | Zenoh NTP-64 timestamp converted to Unix microseconds.          |

All data is stored in a single ReductStore bucket. The bucket is created automatically if it does not exist.

## Configuration

The Zenoh API is configured entirely through environment variables. All variables are optional unless noted.

### Enabling the API

| Name               | Default | Description                                                 |
| ------------------ | ------- | ----------------------------------------------------------- |
| `RS_ZENOH_ENABLED` | `false` | Set to `true`, `1`, `yes`, or `on` to enable the Zenoh API |

No Zenoh sockets are opened until this is set to a truthy value.

### Session Configuration

Exactly **one** of the two variables below is required when `RS_ZENOH_ENABLED=true`:

| Name                   | Default | Description                                                                                  |
| ---------------------- | ------- | -------------------------------------------------------------------------------------------- |
| `RS_ZENOH_CONFIG`      | —       | Inline config string, e.g. `mode=client;peer=tcp/localhost:7447`. Takes precedence over path |
| `RS_ZENOH_CONFIG_PATH` | —       | Path to a Zenoh JSON5 config file (e.g. `/etc/reductstore/zenoh.json5`)                      |

#### Inline config format

The inline config is a semicolon-separated list of `key=value` pairs:

| Key                | Example value              | Description                         |
| ------------------ | -------------------------- | ----------------------------------- |
| `mode`             | `client`, `peer`, `router` | Zenoh session mode                  |
| `peer` / `connect` | `tcp/localhost:7447`       | Comma-separated connect endpoints   |
| `listen`           | `tcp/0.0.0.0:7447`         | Comma-separated listen endpoints    |

```
RS_ZENOH_CONFIG=mode=client;peer=tcp/192.168.1.10:7447
```

Unknown keys are logged as warnings and ignored. For advanced session settings (TLS, multicast discovery, scouting, and so on), use a JSON5 config file instead.

#### JSON5 config file

Pass the path to a standard [Zenoh JSON5 configuration file](https://github.com/eclipse-zenoh/zenoh/blob/main/DEFAULT_CONFIG.json5):

```
RS_ZENOH_CONFIG_PATH=/etc/reductstore/zenoh.json5
```

### Storage Mapping

| Name              | Default | Description                                                            |
| ----------------- | ------- | ---------------------------------------------------------------------- |
| `RS_ZENOH_BUCKET` | `zenoh` | Target ReductStore bucket. Created automatically if it does not exist. |

### Key Expression Routing

| Name                      | Default | Description                                                                      |
| ------------------------- | ------- | -------------------------------------------------------------------------------- |
| `RS_ZENOH_SUB_KEYEXPRS`   | —       | Key expression for the subscriber (write path). Disabled if unset.               |
| `RS_ZENOH_QUERY_KEYEXPRS` | —       | Key expression for the queryable (read path). Disabled if unset.                 |

Use standard Zenoh wildcards: `*` for a single segment, `**` for any number of segments.

| `RS_ZENOH_SUB_KEYEXPRS` | What is matched                               |
| ----------------------- | --------------------------------------------- |
| `**`                    | All key expressions                           |
| `robot1/**`             | All keys under the `robot1` prefix            |
| `factory/line1/*`       | All single-segment keys under `factory/line1` |

## Write Path

When a Zenoh publisher sends a sample to a key expression that matches `RS_ZENOH_SUB_KEYEXPRS`:

1. The full key expression becomes the entry name (leading and trailing `/` are stripped).
2. The sample payload is written to that entry in `RS_ZENOH_BUCKET`.
3. If the sample carries a Zenoh timestamp, it is converted from NTP-64 to Unix microseconds and used as the record timestamp. Otherwise the server clock is used.
4. If the sample carries a Zenoh attachment, it is decoded as a JSON object and stored as record labels.

### Sending Labels

Attach a JSON label map to the Zenoh sample to annotate the record:

```python
import zenoh, json

session = zenoh.open(zenoh.Config())
session.put(
    "factory/line1/camera",
    b"<binary payload>",
    attachment=json.dumps({"robot": "alpha", "status": "ok"}).encode(),
)
```

## Read Path

When a Zenoh client sends a query to a key expression that matches `RS_ZENOH_QUERY_KEYEXPRS`, ReductStore looks up the matching records and replies with them.

The key expression maps to the entry name within `RS_ZENOH_BUCKET`. Query parameters are passed as Zenoh selector parameters (`?key=value&...`).

### Point-in-time Lookup

Fetch the single record at an exact timestamp:

| Parameter | Description                                 | Type      |
| --------- | ------------------------------------------- | --------- |
| `ts`      | Exact record timestamp in Unix microseconds | Timestamp |

```python
replies = session.get("factory/line1/camera?ts=1700000000000000")
for reply in replies:
    print(reply.ok.payload)
```

### Time-range Query

If `ts` is not set, a range query is performed. The following parameters are supported:

| Parameter       | Description                                                                    | Type      | Default                            |
| --------------- | ------------------------------------------------------------------------------ | --------- | ---------------------------------- |
| `start`         | Range start timestamp (Unix µs, inclusive)                                     | Timestamp | Timestamp of the first record      |
| `stop`          | Range stop timestamp (Unix µs, exclusive)                                      | Timestamp | Timestamp of the last record       |
| `each_s`        | Return at most one record every N seconds (must be greater than 0)             | Float     |                                    |
| `each_n`        | Return every Nth record (must be greater than 0)                               | Integer   |                                    |
| `limit`         | Maximum number of records to return                                            | Integer   |                                    |
| `continuous`    | Keep the query alive and stream new records as they arrive                     | Boolean   | False                              |
| `ttl`           | Time-to-live for a continuous query in seconds                                 | Integer   | 60                                 |
| `metadata`      | Return labels and timestamps only, without payload                             | Boolean   | False                              |
| `include-<key>` | Only return records where label `<key>` equals the value, e.g. `include-robot=alpha` | String |                             |
| `exclude-<key>` | Exclude records where label `<key>` equals the value, e.g. `exclude-status=error`   | String |                             |

```python
replies = session.get(
    "factory/line1/camera",
    parameters="start=1700000000000000&stop=1700086400000000&limit=100"
)
for reply in replies:
    print(reply.ok.payload.to_bytes())
```

### Reading Labels from Replies

Labels are returned as a JSON attachment on each reply sample:

```python
import json

for reply in replies:
    sample = reply.ok
    labels = {}
    if sample.attachment is not None:
        labels = json.loads(sample.attachment.to_bytes())
    print(labels)
```

## Quick Start with Docker

Start ReductStore with the Zenoh API in client mode, connecting to a Zenoh router at `192.168.1.10:7447`. All published data lands in the `sensors` bucket.

```bash
docker run -d \
  -p 8383:8383 \
  -v ${PWD}/data:/data \
  -e RS_ZENOH_ENABLED=true \
  -e RS_ZENOH_CONFIG="mode=client;peer=tcp/192.168.1.10:7447" \
  -e RS_ZENOH_BUCKET=sensors \
  -e RS_ZENOH_SUB_KEYEXPRS="**" \
  -e RS_ZENOH_QUERY_KEYEXPRS="**" \
  reduct/store:latest
```

### Using a JSON5 Config File

Mount a config file into the container when you need advanced Zenoh settings:

```bash
docker run -d \
  -p 8383:8383 \
  -v ${PWD}/data:/data \
  -v ${PWD}/zenoh.json5:/etc/reductstore/zenoh.json5:ro \
  -e RS_ZENOH_ENABLED=true \
  -e RS_ZENOH_CONFIG_PATH=/etc/reductstore/zenoh.json5 \
  -e RS_ZENOH_BUCKET=sensors \
  -e RS_ZENOH_SUB_KEYEXPRS="**" \
  reduct/store:latest
```

## Configuration Reference

| Name                      | Default | Description                                                       |
| ------------------------- | ------- | ----------------------------------------------------------------- |
| `RS_ZENOH_ENABLED`        | `false` | Enable the Zenoh API (`true`, `1`, `yes`, `on`)                   |
| `RS_ZENOH_CONFIG`         | —       | Inline Zenoh config string (takes precedence over path)           |
| `RS_ZENOH_CONFIG_PATH`    | —       | Path to a Zenoh JSON5 config file                                 |
| `RS_ZENOH_BUCKET`         | `zenoh` | Target bucket (auto-created if missing)                           |
| `RS_ZENOH_SUB_KEYEXPRS`   | —       | Key expression for the subscriber (write path). Disabled if unset |
| `RS_ZENOH_QUERY_KEYEXPRS` | —       | Key expression for the queryable (read path). Disabled if unset   |

## Using the HTTP API alongside Zenoh

The HTTP API stays fully operational when the Zenoh API is enabled. Data written via Zenoh is immediately visible over HTTP and vice versa. A typical setup uses Zenoh for ingestion from edge nodes and the HTTP API or Web Console for querying, management, and replication.

Data management operations such as deleting records, entries, or buckets are not available through the Zenoh API. Use the [HTTP API](/docs/http-api) for those.

## Authentication

Zenoh has its own access control system, separate from ReductStore API tokens. ReductStore registers itself as a regular Zenoh node. Any Zenoh node that is allowed to connect to the session can publish and query data.

You configure who can connect, and what they can do, at the Zenoh level using:

- [Access control rules](https://zenoh.io/docs/manual/access-control/) to allow or deny operations on specific key expressions per subject
- [User-password authentication](https://zenoh.io/docs/manual/user-password/) to authenticate clients and peers before they join the session
- [TLS authentication](https://zenoh.io/docs/manual/tls/) for mutual certificate-based authentication

ReductStore API tokens are not checked for Zenoh connections. If you need per-token access control on top of Zenoh, use the HTTP API.

## Current Limitations

- **Single-bucket mode.** All Zenoh data maps to one configured bucket. Routing to different buckets based on the key expression is not yet supported.
- **Binary payload only.** The Zenoh API always stores and returns raw bytes with content type `application/octet-stream`. Use labels to carry any semantic metadata.
